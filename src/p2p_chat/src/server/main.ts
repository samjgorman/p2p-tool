import { app, BrowserWindow, ipcMain, protocol, dialog } from "electron";
import signalhub from "signalhub";
import Peer from "simple-peer";
import wrtc from "wrtc";
import fs from "fs-extra";
import * as path from "path";
import readline from "readline";
import "dotenv/config";
import {
  pollIfFriendsOnline,
  listenForConnectionRequests,
  isRemotePeerOnline,
} from "./onlineOffline";

import {
  Keys,
  FriendMetadata,
  PublicChannelMessage,
  PublicChannelMessagePayload,
  InviteResponseMessage,
  InviteAckMessage,
  PeerSignal,
} from "../shared/@types/types";

import { initiateHandshake } from "./invite";
import { acceptHandshake } from "./accept";
import { generateInviteLink, handleInviteLink } from "./linkHelpers";
import { writeToFS, buildChatDir } from "./fileHelpers";
import { getPublicKeyId, generateKeys } from "./keyHelpers";
import { getFriendChatObject } from "./offlineChat";

// This allows TypeScript to pick up the magic constant that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;

//Declaring global variables to be used across the application
let GLOBAL_USER_NAME: string;
let window: BrowserWindow = null; //TODO: declare this type correctly for TS
// let CHAT_SESSION_PATH: string = null;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
  // eslint-disable-line global-require
  app.quit();
}

declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

const createWindow = (): BrowserWindow => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    width: 1100,
    height: 700,
    webPreferences: {
      nodeIntegration: false, //TODO: refactor to false
      contextIsolation: true, //refactor to true
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools.
  mainWindow.webContents.openDevTools();

  return mainWindow;
};

//  This begins the webRTC connection process
async function establishConnection(
  window: BrowserWindow,
  peerMetadata: string
) {
  //  Unpack JSON string to an object
  const peerMetadataObj = JSON.parse(peerMetadata);
  const initiator = peerMetadataObj.initiator;
  const name = peerMetadataObj.data.name;
  GLOBAL_USER_NAME = name;

  //Generate keys
  const mykeys = await generateKeys(name);
  //TODO: refactor
  const identityPath = path.join(__dirname, "../../files", "identities", name);
  const friendsPath = path.join(identityPath, "friends.json");
  let friends: Record<string, FriendMetadata> = {};

  if (await fs.pathExists(friendsPath)) {
    friends = await fs.readJSON(friendsPath);
  }

  console.log("friends");
  console.log(friends);

  //Listen for incoming requests to test availability
  listenForConnectionRequests(mykeys, name, initiator, friends, window);
  //Run this code every 15 seconds
  const timerId = setInterval(function () {
    pollIfFriendsOnline(mykeys, name, initiator, window);
    //Package and send a list of the user's friends
    window.webContents.send("get_all_friends_of_user", friends);
  }, 1000 * 15);

  if (initiator) {
    //Send generated token to client to render
    const recipient = peerMetadataObj.data.recipient;
    initiateHandshake(
      mykeys,
      name,
      initiator,
      recipient,
      friends,
      friendsPath,
      window
    );
  } else {
    const invitedBy = peerMetadataObj.data.invitedBy;
    const inviteToken = peerMetadataObj.data.inviteToken;

    acceptHandshake(
      mykeys,
      name,
      initiator,
      invitedBy,
      inviteToken,
      friends,
      friendsPath,
      window
    );
  }
  //Code doesnt run below
}

async function registerListeners(window: BrowserWindow) {
  /**
   * This comes from bridge integration, check bridge.ts
   */
  ipcMain.on("send_peer_metadata", (_, message) => {
    console.log(message);
    establishConnection(window, message);
  });

  ipcMain.on("get_friend_chat_object", async (event, message) => {
    console.log("Request for getting friend chat object registered" + message);
    const chatObject = await getFriendChatObject(window, message);

    event.reply("friend_chat_object_sent", chatObject);
  });

  //Listen for offline messages
  ipcMain.on("send_message_to_peer", async (event, message) => {
    console.log("Listener for writing new data offline fired");
    // console.log(message); //Message submitted by client
    // const log = formatMessageToStringifiedLog(identity, message); //Check this
    // // const chatSessionPath = await buildChatDir(identity, name);
    // CHAT_SESSION_PATH = await buildChatDir(identity, name);

    // writeToFS(CHAT_SESSION_PATH, log);
    // peer.send(log); //Send the client submitted message to the peer
    // event.reply("i_submitted_message", log); //Send the message back to the renderer process
  });
}

async function registerProtocols() {
  app.setAsDefaultProtocolClient("p2p");
}

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.

app
  .on("ready", () => {
    window = createWindow();
    registerProtocols(); //Register protocol routes
    registerListeners(window);
  })

  .whenReady()
  .then(() => {
    app.on("open-url", (event, url) => {
      event.preventDefault();
      //TODO: rewrite this to send data when app is not open
      handleInviteLink(url, window);
      dialog.showErrorBox("Welcome Back", `You arrived from: ${url}`);
    });
  })

  .catch((e) => console.error(e)); //TODO: check this code

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
  }
});

app.on("activate", () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});
